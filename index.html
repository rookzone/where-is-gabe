<!DOCTYPE html>
<html>
<head>
    <title>GB Pachinko - Level Design Lab</title>
    <style>
        body { background: #0f380f; color: #9bbc0f; font-family: 'Courier New', monospace; display: flex; flex-direction: row; gap: 20px; padding: 20px; height: 100vh; overflow: hidden; }
        #screen-container { background: #306230; padding: 10px; border-radius: 4px; border: 4px solid #8bac0f; flex-shrink: 0; }
        canvas { background: #8bac0f; image-rendering: pixelated; width: 480px; height: 432px; cursor: crosshair; }
        .panel { background: #306230; padding: 15px; width: 400px; border-radius: 4px; border: 2px solid #8bac0f; overflow-y: auto; }
        .control-group { border: 1px solid #8bac0f; padding: 10px; margin-bottom: 10px; border-radius: 2px; }
        input, button, select { background: #8bac0f; border: none; padding: 8px; margin: 5px 0; width: 100%; color: #0f380f; font-weight: bold; font-family: inherit; }
        h3 { margin-top: 0; border-bottom: 1px solid #8bac0f; padding-bottom: 5px; font-size: 16px; }
        label { font-size: 11px; text-transform: uppercase; display: block; margin-top: 5px;}
        #histogram { height: 120px; display: flex; align-items: flex-end; gap: 1px; background: #0f380f; padding: 5px; margin-top: 10px; border: 1px solid #8bac0f; }
        .bar { background: #9bbc0f; flex-grow: 1; min-width: 2px; }
        .stats-text { font-size: 12px; line-height: 1.5; color: #e0f8d0; }
    </style>
</head>
<body>

<div id="screen-container">
    <canvas id="gbCanvas" width="160" height="144"></canvas>
    <div id="histogram"></div>
    <div style="font-size: 10px; text-align: center; margin-top: 5px; color: #8bac0f;">EXIT PROBABILITY DISTRIBUTION</div>
</div>

<div class="panel">
    <h3>GB LEVEL DESIGNER</h3>
    
    <div class="control-group">
        <label>Pin Layout Generator</label>
        <select id="generatorSelect" onchange="updateGeneratorUI()">
            <option value="staggered">Standard Staggered</option>
            <option value="funnel">The Funnel (Convergent)</option>
            <option value="random">Random Scatter (Procedural)</option>
            <option value="empty">Empty Table</option>
        </select>
        
        <div id="genParams">
            </div>
        <button onclick="applyGenerator()" style="background: #e0f8d0;">APPLY LAYOUT</button>
    </div>

    <div class="control-group">
        <label>Simulation Params</label>
        <div style="display:flex; gap:5px;">
            <div style="flex:1">
                <label>Spawn X</label>
                <input type="number" id="launchX" value="80">
            </div>
            <div style="flex:1">
                <label>Jitter</label>
                <input type="number" id="jitter" value="40">
            </div>
        </div>
        <label>Batch Size (Balls)</label>
        <input type="number" id="batchSize" value="25">
        <button onclick="runSimulation()">RUN SIMULATION</button>
    </div>

    <button onclick="resetData()" style="background:#0f380f; color:#8bac0f; border:1px solid #8bac0f;">CLEAR RESULTS</button>
    
    <div id="stats" class="stats-text" style="margin-top:15px;">
        Active: 0 | Total Samples: 0
    </div>

    <div style="font-size: 10px; color: #8bac0f; margin-top: 20px; border-top: 1px solid #8bac0f; padding-top: 10px;">
        * PHYS: Fixed-point 8.8 (Damp 0.5)<br>
        * NUDGE: Y-Bit Symmetry Break
    </div>
</div>

<script>
// === CONSTANTS (MATCHING PHYSICS.C) ===
const FIXED_SHIFT = 8;
const GRAVITY = 16;
const MAX_SPEED = 512;
const MAX_ROLL_SPEED = 512;
const PIN_TILE_ID = 2;

const canvas = document.getElementById('gbCanvas');
const ctx = canvas.getContext('2d');
let balls = [];
let exitPositions = new Array(160).fill(0);
let frameCounter = 0;
let tilemap = new Uint8Array(20 * 18);

// === PIN GENERATOR REGISTRY ===
// ADD YOUR OWN GENERATORS HERE!
const GENERATORS = {
    staggered: {
        params: { spacing: 2, startRow: 4, endRow: 14 },
        generate: (p) => {
            for(let r = p.startRow; r < p.endRow; r += 2) {
                let offset = (r % 4 === 0) ? 0 : 1;
                for(let c = 2; c < 18; c += p.spacing) {
                    setTile(c + offset, r, PIN_TILE_ID);
                }
            }
        }
    },
    funnel: {
        params: { width: 8, startRow: 4 },
        generate: (p) => {
            for(let r = 0; r < 12; r++) {
                let row = p.startRow + r;
                let inset = Math.floor(r * 0.6);
                setTile(10 - p.width + inset, row, PIN_TILE_ID);
                setTile(10 + p.width - inset, row, PIN_TILE_ID);
            }
        }
    },
    random: {
        params: { count: 40, minRow: 4, maxRow: 15 },
        generate: (p) => {
            for(let i = 0; i < p.count; i++) {
                let x = Math.floor(Math.random() * 16) + 2;
                let y = Math.floor(Math.random() * (p.maxRow - p.minRow)) + p.minRow;
                setTile(x, y, PIN_TILE_ID);
            }
        }
    },
    empty: {
        params: {},
        generate: () => {}
    }
};

function setTile(x, y, id) {
    if (x >= 0 && x < 20 && y >= 0 && y < 18) {
        tilemap[y * 20 + x] = id;
    }
}

// === UI LOGIC ===
function updateGeneratorUI() {
    const type = document.getElementById('generatorSelect').value;
    const params = GENERATORS[type].params;
    const container = document.getElementById('genParams');
    container.innerHTML = '';
    
    for (let key in params) {
        container.innerHTML += `
            <label>${key}</label>
            <input type="number" id="param_${key}" value="${params[key]}">
        `;
    }
}

function applyGenerator() {
    const type = document.getElementById('generatorSelect').value;
    const inputs = document.querySelectorAll('#genParams input');
    const p = {};
    inputs.forEach(input => {
        p[input.id.replace('param_', '')] = parseInt(input.value);
    });
    
    tilemap.fill(0);
    GENERATORS[type].generate(p);
    resetData();
}

// === PHYSICS ENGINE (PORTED FROM PHYSICS.C) ===
class GBBall {
    constructor(x, y, vx, vy) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.accX = 0; this.accY = 0; this.active = true;
    }

    update() {
        if (!this.active) return;
        this.vy += GRAVITY;
        if (this.vy > MAX_SPEED) this.vy = MAX_SPEED;

        // GB Frame Skip Collision
        if (!(frameCounter & 1) || (this.vy > (MAX_SPEED >> 1))) {
            this.checkCollision();
        }

        this.accX += this.vx; this.accY += this.vy;
        this.x += (this.accX >> FIXED_SHIFT);
        this.y += (this.accY >> FIXED_SHIFT);
        this.accX &= 0xFF; this.accY &= 0xFF;

        if (this.y >= 144) {
            this.active = false;
            exitPositions[Math.max(0, Math.min(159, Math.floor(this.x + 4)))]++;
            updateHistogram();
        }
    }

    checkCollision() {
        if (this.vy <= 0) return;
        let bx = this.x + 4, by = this.y + 8;
        let col = bx >> 3, row = by >> 3;
        if (col >= 20 || row >= 18) return;

        if (tilemap[row * 20 + col] === PIN_TILE_ID) {
            let distX = bx - ((col << 3) + 4);
            if (distX < -3 || distX > 3) return;
            if ((by - ((row << 3) + 3)) < 0 || (by - ((row << 3) + 3)) > 4) return;

            this.accY = 0;
            if (this.vy > 64) { // FIXED_QUARTER
                this.vy = -(this.vy >> 1);
                if ((this.vx > 0 && distX < 0) || (this.vx < 0 && distX > 0)) {
                    this.vx = -(this.vx >> 1);
                } else {
                    this.vx = (this.vx >> 1);
                    if (distX > 0) this.vx += 32;
                    else if (distX < 0) this.vx -= 32;
                    else this.vx += (this.y & 1) ? 32 : -32; // Symmetry break
                }
            } else {
                this.vy = 0;
                this.vx += distX;
                if (this.vx > MAX_ROLL_SPEED) this.vx = MAX_ROLL_SPEED;
                if (this.vx < -MAX_ROLL_SPEED) this.vx = -MAX_ROLL_SPEED;
            }
        }
    }

    draw() {
        ctx.fillStyle = '#0f380f';
        ctx.beginPath();
        ctx.arc(this.x + 4, this.y + 4, 3, 0, Math.PI * 2);
        ctx.fill();
    }
}

function runSimulation() {
    const count = parseInt(document.getElementById('batchSize').value);
    const startX = parseInt(document.getElementById('launchX').value);
    const jitter = parseInt(document.getElementById('jitter').value);

    for (let i = 0; i < count; i++) {
        const jX = (Math.random() * jitter * 2) - jitter;
        balls.push(new GBBall(startX, 10, jX, 0));
    }
}

function updateHistogram() {
    const hist = document.getElementById('histogram');
    const maxVal = Math.max(...exitPositions, 1);
    hist.innerHTML = exitPositions.map(val => 
        `<div class="bar" style="height: ${(val/maxVal)*100}%"></div>`
    ).join('');
}

function resetData() {
    exitPositions.fill(0);
    balls = [];
    updateHistogram();
}

function loop() {
    frameCounter++;
    ctx.fillStyle = '#8bac0f';
    ctx.fillRect(0, 0, 160, 144);

    ctx.fillStyle = '#306230';
    for (let i = 0; i < 360; i++) {
        if (tilemap[i] === PIN_TILE_ID) {
            ctx.fillRect(((i % 20) << 3) + 2, (Math.floor(i / 20) << 3) + 2, 4, 4);
        }
    }

    balls = balls.filter(b => b.active);
    balls.forEach(b => { b.update(); b.draw(); });

    document.getElementById('stats').innerText = `Active: ${balls.length} | Total Samples: ${exitPositions.reduce((a,b)=>a+b,0)}`;
    requestAnimationFrame(loop);
}

// Init
updateGeneratorUI();
applyGenerator();
loop();
</script>
</body>
</html>
