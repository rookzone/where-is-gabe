<!DOCTYPE html>
<html>
<head>
    <title>GB Pachinko - Level Design Lab</title>
    <style>
        body { background: #0f380f; color: #9bbc0f; font-family: 'Courier New', monospace; display: flex; flex-direction: row; gap: 20px; padding: 20px; height: 100vh; overflow: hidden; }
        #screen-container { background: #306230; padding: 10px; border-radius: 4px; border: 4px solid #8bac0f; flex-shrink: 0; }
        canvas { background: #8bac0f; image-rendering: pixelated; width: 480px; height: 432px; cursor: crosshair; }
        .panel { background: #306230; padding: 15px; width: 400px; border-radius: 4px; border: 2px solid #8bac0f; overflow-y: auto; }
        .control-group { border: 1px solid #8bac0f; padding: 10px; margin-bottom: 10px; border-radius: 2px; }
        input, button, select { background: #8bac0f; border: none; padding: 8px; margin: 5px 0; width: 100%; color: #0f380f; font-weight: bold; font-family: inherit; }
        h3 { margin-top: 0; border-bottom: 1px solid #8bac0f; padding-bottom: 5px; font-size: 16px; }
        label { font-size: 11px; text-transform: uppercase; display: block; margin-top: 5px;}
        #histogram { height: 120px; display: flex; align-items: flex-end; gap: 1px; background: #0f380f; padding: 5px; margin-top: 10px; border: 1px solid #8bac0f; }
        .bar { background: #9bbc0f; flex-grow: 1; min-width: 2px; }
        .stats-text { font-size: 12px; line-height: 1.5; color: #e0f8d0; }
    </style>
</head>
<body>

<div id="screen-container">
    <canvas id="gbCanvas" width="160" height="144"></canvas>
    
    <div id="histogram"></div>
    
    <div id="histLabels" style="display:flex; position:relative; height:12px; margin-top:2px; border-top:1px solid #8bac0f;">
        </div>
    
    <div style="font-size: 10px; text-align: center; margin-top: 5px; color: #8bac0f;">EXIT PROBABILITY DISTRIBUTION</div>
    
    <button onclick="exportToCSV()" style="margin-top:10px; background:#0f380f; color:#8bac0f; border:1px solid #8bac0f; font-size:10px;">ðŸ’¾ EXPORT DISTRIBUTION TO CSV</button>
</div>

<div class="panel">
    <h3>GB LEVEL DESIGNER</h3>
    
    <div class="control-group">
        <label>Pin Layout Generator</label>
        <select id="generatorSelect" onchange="updateGeneratorUI()">
            <option value="staggered">Standard Staggered</option>
            <option value="funnel">The Funnel (Convergent)</option>
            <option value="random">Random Scatter (Procedural)</option>
            <option value="empty">Empty Table</option>
        </select>
        
        <div id="genParams">
            </div>
        <button onclick="applyGenerator()" style="background: #e0f8d0;">APPLY LAYOUT</button>
    </div>

    <div class="control-group">
        <label>Spawn Management</label>
        <button id="spawnPickerBtn" onclick="toggleSpawnSelection()" style="margin-top:10px; border: 1px dashed #0f380f;">+ ADD DROP ZONE</button>
        
        <div id="zonesList" style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
            </div>

        <div style="border-top: 1px solid #8bac0f; margin-top: 10px; padding-top: 10px;">
            <label>Global Jitter</label>
            <input type="number" id="jitter" value="40">
            <button onclick="runSimulation()" style="background: #e0f8d0; margin-top: 10px;">RUN ALL ZONES</button>
        </div>
    </div>

    <button onclick="resetData()" style="background:#0f380f; color:#8bac0f; border:1px solid #8bac0f;">CLEAR RESULTS</button>
    
    <div id="stats" class="stats-text" style="margin-top:15px;">
        Active: 0 | Total Samples: 0
    </div>

    <div style="font-size: 10px; color: #8bac0f; margin-top: 20px; border-top: 1px solid #8bac0f; padding-top: 10px;">
        * PHYS: Fixed-point 8.8 (Damp 0.5)<br>
        * NUDGE: Y-Bit Symmetry Break
    </div>
</div>

<script>
// === CONSTANTS (MATCHING PHYSICS.C) ===
const FIXED_SHIFT = 8;
const GRAVITY = 16;
const MAX_SPEED = 512;
const MAX_ROLL_SPEED = 512;
const PIN_TILE_ID = 2;

const canvas = document.getElementById('gbCanvas');
const ctx = canvas.getContext('2d');
let balls = [];
let exitPositions = new Array(160).fill(0);
let frameCounter = 0;
let tilemap = new Uint8Array(20 * 18);



// === PIN GENERATOR REGISTRY ===
// ADD YOUR OWN GENERATORS HERE!
const GENERATORS = {
    staggered: {
        params: { spacing: 2, startRow: 4, endRow: 14 },
        generate: (p) => {
            for(let r = p.startRow; r < p.endRow; r += 2) {
                let offset = (r % 4 === 0) ? 0 : 1;
                for(let c = 2; c < 18; c += p.spacing) {
                    setTile(c + offset, r, PIN_TILE_ID);
                }
            }
        }
    },
    funnel: {
        params: { width: 8, startRow: 4 },
        generate: (p) => {
            for(let r = 0; r < 12; r++) {
                let row = p.startRow + r;
                let inset = Math.floor(r * 0.6);
                setTile(10 - p.width + inset, row, PIN_TILE_ID);
                setTile(10 + p.width - inset, row, PIN_TILE_ID);
            }
        }
    },
    random: {
        params: { count: 40, minRow: 4, maxRow: 15 },
        generate: (p) => {
            for(let i = 0; i < p.count; i++) {
                let x = Math.floor(Math.random() * 16) + 2;
                let y = Math.floor(Math.random() * (p.maxRow - p.minRow)) + p.minRow;
                setTile(x, y, PIN_TILE_ID);
            }
        }
    },
    empty: {
        params: {},
        generate: () => {}
    }
};

function setTile(x, y, id) {
    if (x >= 0 && x < 20 && y >= 0 && y < 18) {
        tilemap[y * 20 + x] = id;
    }
}

// === UI LOGIC ===
function updateGeneratorUI() {
    const type = document.getElementById('generatorSelect').value;
    const params = GENERATORS[type].params;
    const container = document.getElementById('genParams');
    container.innerHTML = '';
    
    for (let key in params) {
        container.innerHTML += `
            <label>${key}</label>
            <input type="number" id="param_${key}" value="${params[key]}">
        `;
    }
}

function applyGenerator() {
    const type = document.getElementById('generatorSelect').value;
    const inputs = document.querySelectorAll('#genParams input');
    const p = {};
    inputs.forEach(input => {
        p[input.id.replace('param_', '')] = parseInt(input.value);
    });
    
    tilemap.fill(0);
    GENERATORS[type].generate(p);
    resetData();
}

// === PHYSICS ENGINE (PORTED FROM PHYSICS.C) ===
class GBBall {
    constructor(x, y, vx, vy) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.accX = 0; this.accY = 0; this.active = true;
    }

    update() {
        if (!this.active) return;
        this.vy += GRAVITY;
        if (this.vy > MAX_SPEED) this.vy = MAX_SPEED;

        // GB Frame Skip Collision
        if (!(frameCounter & 1) || (this.vy > (MAX_SPEED >> 1))) {
            this.checkCollision();
        }

        this.accX += this.vx; this.accY += this.vy;
        this.x += (this.accX >> FIXED_SHIFT);
        this.y += (this.accY >> FIXED_SHIFT);
        this.accX &= 0xFF; this.accY &= 0xFF;

        if (this.y >= 144) {
            this.active = false;
            exitPositions[Math.max(0, Math.min(159, Math.floor(this.x + 4)))]++;
            updateHistogram();
        }
    }

    checkCollision() {
        if (this.vy <= 0) return;
        let bx = this.x + 4, by = this.y + 8;
        let col = bx >> 3, row = by >> 3;
        if (col >= 20 || row >= 18) return;

        if (tilemap[row * 20 + col] === PIN_TILE_ID) {
            let distX = bx - ((col << 3) + 4);
            if (distX < -3 || distX > 3) return;
            if ((by - ((row << 3) + 3)) < 0 || (by - ((row << 3) + 3)) > 4) return;

            this.accY = 0;
            if (this.vy > 64) { // FIXED_QUARTER
                this.vy = -(this.vy >> 1);
                if ((this.vx > 0 && distX < 0) || (this.vx < 0 && distX > 0)) {
                    this.vx = -(this.vx >> 1);
                } else {
                    this.vx = (this.vx >> 1);
                    if (distX > 0) this.vx += 32;
                    else if (distX < 0) this.vx -= 32;
                    else this.vx += (this.y & 1) ? 32 : -32; // Symmetry break
                }
            } else {
                this.vy = 0;
                this.vx += distX;
                if (this.vx > MAX_ROLL_SPEED) this.vx = MAX_ROLL_SPEED;
                if (this.vx < -MAX_ROLL_SPEED) this.vx = -MAX_ROLL_SPEED;
            }
        }
    }

    draw() {
        ctx.fillStyle = '#0f380f';
        ctx.beginPath();
        ctx.arc(this.x + 4, this.y + 4, 3, 0, Math.PI * 2);
        ctx.fill();
    }
}

function addNewZone(x, y) {
    // We create the object with explicit default values here
    const newZone = {
        x: x,
        y: y,
        count: 25,   // Default Count
        jitter: 40,  // Default Jitter
        vx: 10,       // Default Force VX
        vy: 10        // Default Force VY
    };
    
    dropZones.push(newZone);
    updateZonesUI(); // This forces the HTML to redraw with the data above
}

function runSimulation() {
    dropZones.forEach(zone => {
        for (let i = 0; i < zone.count; i++) {
            // Apply jitter to horizontal launch
            const jX = (Math.random() * zone.jitter * 2) - zone.jitter;
            balls.push(new GBBall(zone.x, zone.y, zone.vx + jX, zone.vy));
        }
    });
}

function exportToCSV() {
    const total = exitPositions.reduce((a, b) => a + b, 0);
    if (total === 0) return alert("No simulation data to export!");

    let csv = "X_Pixel,Count,Probability\n";
    exitPositions.forEach((count, x) => {
        const prob = (count / total).toFixed(6);
        csv += `${x},${count},${prob}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.setAttribute('hidden', '');
    a.setAttribute('href', url);
    a.setAttribute('download', `gb_pachinko_dist_${Date.now()}.csv`);
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function updateHistogram() {
    const hist = document.getElementById('histogram');
    const maxVal = Math.max(...exitPositions, 1);
    hist.innerHTML = exitPositions.map(val => 
        `<div class="bar" style="height: ${(val/maxVal)*100}%"></div>`
    ).join('');
}

function resetData() {
    exitPositions.fill(0);
    balls = [];
    updateHistogram();
}

function initLabels() {
    const labelContainer = document.getElementById('histLabels');
    labelContainer.innerHTML = '';
    for (let i = 0; i <= 160; i += 16) { // Every 16px (2 tiles) for clarity
        const label = document.createElement('span');
        label.innerText = i;
        label.style.cssText = `position:absolute; left:${(i/160)*100}%; transform:translateX(-50%); font-size:8px; color:#8bac0f;`;
        labelContainer.appendChild(label);
    }
}

function loop() {
    frameCounter++;
    
    // 1. Clear Screen
    ctx.fillStyle = '#8bac0f'; 
    ctx.fillRect(0, 0, 160, 144);

    // 2. Draw Tiles (Pins)
    ctx.fillStyle = '#306230'; 
    for (let i = 0; i < 360; i++) {
        if (tilemap[i] === PIN_TILE_ID) {
            ctx.fillRect(((i % 20) << 3) + 2, (Math.floor(i / 20) << 3) + 2, 4, 4);
        }
    }

    // 3. Draw Tile Highlighter (Only if NOT placing a spawn point)
    if (mousePixelX !== -1 && !isSelectingSpawn) {
        ctx.strokeStyle = '#306230';
        ctx.lineWidth = 0.5;
        ctx.setLineDash([2, 2]);
        ctx.strokeRect(hoverX * 8 + 0.5, hoverY * 8 + 0.5, 7, 7);
        ctx.setLineDash([]);
    }

    // 4. Draw All Saved Drop Zones
    dropZones.forEach((zone, index) => {
        ctx.save();
        ctx.globalAlpha = 0.6; // Transparentish style
        ctx.fillStyle = '#0f380f';
        
        // Draw the point
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw the Zone Number Label
        ctx.globalAlpha = 1.0;
        ctx.font = '6px monospace';
        ctx.fillText(index + 1, zone.x + 4, zone.y - 2);
        ctx.restore();
    });

    // 5. Draw Placement Preview (Crosshairs)
    if (isSelectingSpawn && mousePixelX !== -1) {
        ctx.save();
        ctx.strokeStyle = '#0f380f';
        ctx.setLineDash([1, 1]);
        ctx.beginPath();
        // Horizontal guide following mouse
        ctx.moveTo(0, mousePixelY); ctx.lineTo(160, mousePixelY); 
        // Vertical guide following mouse
        ctx.moveTo(mousePixelX, 0); ctx.lineTo(mousePixelX, 144); 
        ctx.stroke();
        
        // Preview dot at mouse
        ctx.beginPath();
        ctx.arc(mousePixelX, mousePixelY, 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }

    // 6. Update and Draw Balls
    balls = balls.filter(b => b.active);
    balls.forEach(b => { 
        b.update(); 
        b.draw(); 
    });

    // 7. Update Stats UI
    const totalSamples = exitPositions.reduce((a, b) => a + b, 0);
    document.getElementById('stats').innerText = `Active: ${balls.length} | Total Samples: ${totalSamples}`;
    
    requestAnimationFrame(loop);
}

// === SPAWN POINT STATE ===
let dropZones = []; // Array of {x, y, count}
let isSelectingSpawn = false;

function toggleSpawnSelection() {
    isSelectingSpawn = !isSelectingSpawn;
    const btn = document.getElementById('spawnPickerBtn');
    btn.innerText = isSelectingSpawn ? "CLICK CANVAS TO PLACE" : "+ ADD DROP ZONE";
    btn.style.background = isSelectingSpawn ? "#e0f8d0" : "#8bac0f";
}

function updateZonesUI() {
    const container = document.getElementById('zonesList');
    container.innerHTML = '';
    
    dropZones.forEach((zone, index) => {
        const zoneEl = document.createElement('div');
        zoneEl.className = 'control-group';
        zoneEl.style.cssText = 'margin:5px 0; padding:8px; background:rgba(15, 56, 15, 0.2); border:1px solid #8bac0f;';
        
        zoneEl.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <span style="font-size:10px; font-weight:bold;">ZONE ${index + 1} (${zone.x},${zone.y})</span>
                <button onclick="removeZone(${index})" style="width:20px; height:20px; padding:0; background:#ff4444; color:white; border:none;">Ã—</button>
            </div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                <div>
                    <label style="font-size:9px;">Count</label>
                    <input type="number" value="${zone.count}" onchange="dropZones[${index}].count = parseInt(this.value)">
                </div>
                <div>
                    <label style="font-size:9px;">Jitter</label>
                    <input type="number" value="${zone.jitter}" onchange="dropZones[${index}].jitter = parseInt(this.value)">
                </div>
                <div>
                    <label style="font-size:9px;">Force VX</label>
                    <input type="number" value="${zone.vx}" onchange="dropZones[${index}].vx = parseInt(this.value)">
                </div>
                <div>
                    <label style="font-size:9px;">Force VY</label>
                    <input type="number" value="${zone.vy}" onchange="dropZones[${index}].vy = parseInt(this.value)">
                </div>
            </div>
        `;
        container.appendChild(zoneEl);
    });
}

function removeZone(index) {
    dropZones.splice(index, 1);
    updateZonesUI();
}

// === INTERACTIVE EDITOR ===
// Update Mouse Down to push to array
canvas.addEventListener('mousedown', () => {
    if (mousePixelX < 0) return;

    if (isSelectingSpawn) {
        // CALL the function that sets the defaults
        addNewZone(mousePixelX, mousePixelY); 
        toggleSpawnSelection(); 
    } else {
        const index = hoverY * 20 + hoverX;
        if (index >= 0 && index < 360) {
            tilemap[index] = (tilemap[index] === PIN_TILE_ID) ? 0 : PIN_TILE_ID;
            resetData();
        }
    }
});

// === EDITOR STATE ===
let mousePixelX = -1; 
let mousePixelY = -1;
let hoverX = -1;
let hoverY = -1;

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    // Calculate and save raw pixel coordinates for spawn placement
    mousePixelX = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
    mousePixelY = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));
    
    // Calculate grid coordinates for pin placement
    hoverX = Math.floor(mousePixelX / 8);
    hoverY = Math.floor(mousePixelY / 8);
});

canvas.addEventListener('mouseleave', () => {
    hoverX = -1;
    hoverY = -1;
    mousePixelX = -1;
    mousePixelY = -1;
});

// Init
updateGeneratorUI();
applyGenerator();
loop();
</script>
</body>
</html>
